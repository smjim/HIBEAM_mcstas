/*******************************************************************************
* Component: (VENBLA)
*
* %I
* Written by: James Rogers (jroger87@vols.utk.edu)
* Date: Jan 5, 2023
* Origin: University of Tennessee, Knoxville
* Version: 1.0
*
* %D
* Models a differential neutron focusing device using
* a series of mirrors to reflect neutrons to target
*
* Neutron-reflective horizontal blades of equal angle spacing from source,
* with a gap in the middle to allow passage of on-course neutrons
* Blades are angled such that ray from source to center of blade will be
* deflected towards center of target
*
* Similar concept to 'nested reflector' used in X-Ray astonomy, but instead
* using flat surfaces to account for vx, vy deviation independently
*
* %P
* INPUT PARAMETERS:
*
* zvb: [m]	z position of vb
* zdet: [m]	z position of detector
* len: [m]	blade length (z)
* thickness: [m]	thickness of 'dead zone' substrate (y)
* hvb: [m]	height of vb array (y)
* wvb: [m]	width of vb array (x)
* hdet: [m]	height of detector (y)
* mi: [1]	m value of material
* reflect: [str]	Name of reflectivity file. Format q(nm-1) R(0-1). Leave "0" for 100% reflectivity
*
* %L
* See also <A HREF="https://www.desmos.com/calculator/hln2tu6ozw">Desmos interactive model
*
*
* %End
*
*******************************************************************************/

DEFINE COMPONENT Venbla
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string reflect=0, zvb, zdet, len=0.30, thickness = 0.002,
	hvb, wvb, hdet, mi=6)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */
SHARE
%{
	%include "read_table-lib"
	%include "ref-lib"
%}

DECLARE
%{
	t_Table pTable;

	/* total number of blades in vb array */
	int numBlades;

	/* vb generated for angles between these two ranges on either side */
	double outer_angle;
	double inner_angle;

	/* y position and angular rotation of blades */
	DArray1d y_vals;
	DArray1d angles;

	/* normal vectors to blade surface */
	DArray1d norm_y;
	DArray1d norm_z;
%}

INITIALIZE
%{
	/* checking for errors */
	if (zdet < 2.*zvb)
		{ fprintf(stderr,"vb: %s: Error: invalid focus distance\n", NAME_CURRENT_COMP); exit(-1); }
	if (zvb*zdet*len*thickness*hdet*hvb*wvb == 0)
		{ fprintf(stderr,"vb: error: %s has one of zvb,zdet,len,thickness,hdet,hvb null.\n", NAME_CURRENT_COMP); exit(-1); }

	if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0")) {
		if (Table_Read(&pTable, reflect, 1) <= 0) /* read 1st block data from file into pTable */
			exit(fprintf(stderr,"Mirror: %s: can not read file %s\n", NAME_CURRENT_COMP, reflect));
	}

	/* defining geometry */
	// assume that there will be less than 1000 blades used
	y_vals = create_darr1d(1000);
	angles = create_darr1d(1000);
	norm_y = create_darr1d(1000);
	norm_z = create_darr1d(1000);

	/* inner angle, outer angle of vb blades */
	inner_angle = atan((hdet/2.)/zdet);
	outer_angle = atan((hvb/2.)/zvb);

	/* 
	step by step for finding blade position, angle which will be used to define
	 bounding box for intersection and such and such ...
		1. start with top blade, pos = (z0, hvb), angle = formula given y=hvb, z=z0
		2. using center pos, angle, length, find angle towards top right point of blade
		3. using angle toward top right point of blade, find intersection with z0 to define start (bottom left) point of next blade
		4. find angle of new blade through (???)
			a. there may be an analytical solution to this geometric problem but I am unable to figure it out right now unfortunately
			b. current implementation will work by numerical approximation
	*/

	// define blade 0 params
	// while blades within max angle, min angle do:
		// define next blade from previous blade
		// find angle of blade *no analytical method found yet
			// theta_maxb = angle to hit pos (will be already calculated in order to find hit pos)
			// vary ypos from y_hit to y_hit+tan(theta_maxb)
				// test if reflection off blade hits y_target at z1
				// if y_z1>y_target then adjust angle lower, if y_z1<y_target adjust angle higher 
					// repeat until y_z1-y_target within threshold (0.01)
					// *possible for great improve this numerical method
					// *angle adjustment proportional to difference
	
	/* define top blade */
	// pos = (z0, hvb)
	y_vals[0] = hvb/2.;
	// mirror angle required for reflection
	angles[0] = 0.5*(atan((hvb/2.)/zvb) - atan(hvb/(zdet-zvb)));

	/* define upper blade array */
	int i = 0;
	//fprintf(stderr,"inner angle: %f, outer angle: %f\n", inner_angle, outer_angle); 
	while ((inner_angle <= atan(y_vals[i]/zvb)) && (atan(y_vals[i]/zvb) <= outer_angle))
	{
		i += 1;

		// angle for ray to max z of previous blade
		double theta = atan((y_vals[i-1]+(len/2.)*tan(angles[i-1]))/(zvb+len/2.));

		double y0 = (zvb-(len/2.))*tan(theta);

		//// using kamyshkov's iterative\' method
		double yrc = y0;		// yrc is y center of reflection on blade, initially defined as start of blade
		double yrctmp = yrc+1;	// yrctmp is previous yrc, used to determine when to end loop
		double ydet = 0;		// placeholder for y pos of detector, can be shifted throughout run to counteract effect of gravity on slow neutrons
		double ysrc = 0;		// placeholder for y pos of source

		while (yrctmp-yrc < 0.000001)
		{
			yrctmp = yrc;
			double delta = 0.5*(atan((zdet-(zvb+len/2.))/(yrc-ydet))-atan((len/2.)/(yrc-ysrc)));

			yrc = y0+tan(delta)*(len/2.);
		}
		y_vals[i] = yrc;
		angles[i] = atan((yrc-y0)/(len/2.));

		//fprintf(stderr,"i: %d, angle: %f, yrc: %f\n", i, angles[i], y_vals[i]); 
	}

	// define lower blades **currently not functional with ydet focusing, correction for gravitational effect
	for (int j = i+1; j < 2*(i+1); j++)
	{
		angles[j] = -angles[j-i];
		y_vals[j] = -y_vals[j-i];
	}

	numBlades = 2*(i+1);
	fprintf(stderr,"numBlades: %d\n", numBlades); 

	/* normal vector for blade surface (y, z) */
	for (int j=0; j<i+1; j++)
	{
		double theta = angles[j];
		norm_y[j] = -cos(theta);
		norm_z[j] = sin(theta);
		norm_y[j+(i+1)] = -norm_y[j]; 
		norm_z[j+(i+1)] = norm_z[j];
	}
%}

TRACE
%{
	/* placeholder values for translation, rotation of VB blades */
	double t0, t1, yp, zp, vyp, vzp;
	double tmp;
	/* values for reflection */
	double q, B;

	/* loop through all blade angles to check for interactions */
	for (int i=0; i<numBlades; i++)
	{

		/* 'mirror' intersection: */
		
		/* translation */
		yp = y-y_vals[i];
		zp = z;
		/* rotation */
		double theta = angles[i];
		/* rotate vectors by -theta for box_intersect to consider vb 'box' as
			if rotated by +theta */
		tmp = zp*cos(-theta) - yp*sin(-theta);
		yp = zp*sin(-theta) + yp*cos(-theta);
		zp = tmp;
		vzp = vz*cos(-theta) - vy*sin(-theta);
		vyp = vz*sin(-theta) + vy*cos(-theta);

		double mirror_thickness = 0.0001; // 0.1 mm - arbitrarily small thickness of reflective mirror
		if (box_intersect(&t0, &t1, x, yp, zp, vx, vyp, vzp, wvb/2., mirror_thickness, len)) {
			if (t1>=0) {
				PROP_DT(t0);
				double vi = vy*norm_y[i] + vz*norm_z[i];	// calculate incident velocity (scalar_prod(v,norm))
				q = fabs(2*vi*V2Q);							// calculate q[Ã…-1] given v[m/s]

				// look up reflection probability given momentum
				if (reflect && strlen(reflect) && strcmp(reflect,"NULL") && strcmp(reflect,"0"))
					TableReflecFunc(q, &pTable, &B);
			
				// absorb, update prob given vi calculation
				if (B <= 0) ABSORB;
				p *= B;
				SCATTER;

				// reflect neutron around nomal vector 
				double n_dot_v = vy*norm_y[i] + vz*norm_z[i]; 
				vy = vy - 2*n_dot_v*norm_y[i];
				vz = vz - 2*n_dot_v*norm_z[i];
			}
		}

		/* 'dead zone' intersection: */

		/* center of dead zone is slightly offset from center of mirror */
		yp = (y_vals[i] - 0.5*thickness*norm_y[i]);
		zp = -(0.5*thickness*norm_z[i]);
		// rotate
		tmp = zp*cos(-theta) - yp*sin(-theta);
		yp = zp*sin(-theta) + yp*cos(-theta);
		zp = tmp;

		if (box_intersect(&t0, &t1, x, yp, zp, vx, vyp, vzp, wvb/2., thickness, len)) {
			if (t1>=0) {
				PROP_DT((t1+t0)/2);
				SCATTER;
				ABSORB;
			}
		}

	}

%}

MCDISPLAY
%{
	// TODO: neutron rays seem to be reflected from above blades in trace; display problem or reflection problem?
	for (int i=0; i<numBlades; i++)
	{	
		// center of box = (0, yp, zp)
		double yp = y_vals[i] - 0.5*thickness*norm_y[i];
		double zp = -0.5*thickness*norm_z[i];
		double theta = angles[i];

		/* absorbers */
		double xp, ypy, ypz, zpy, zpz;
		double ytmp, ztmp;
		xp = wvb/2.;
		ypy = 0.5*thickness;
		zpz = 0.5*len;
		ypz = 0; zpy = 0;

		// rotate vectors yp, zp by (theta, 0, 0)
		/* y:(0,.5*thickness,0)	-> yp:(0,ypy,ypz)
		   z:(0,0,.5*len)		-> zp:(0,zpy,zpz) */
		ytmp = ypz*cos(theta) - ypy*sin(theta); 
		ypy = ypz*sin(theta) + ypy*cos(theta); 
		ypz = ytmp;
		ztmp = zpz*cos(theta) - zpy*sin(theta); 
		zpy = zpz*sin(theta) + zpy*cos(theta); 
		zpz = ztmp;

		// use vector addition with yp, zp to create vertices of box
		// drawing all 12 edges of a rectangle
		multiline(8,-xp, yp-ypy-zpy, zp-ypz-zpz,
					-xp, yp-ypy+zpy, zp-ypz+zpz,
					+xp, yp-ypy+zpy, zp-ypz+zpz,
					+xp, yp-ypy-zpy, zp-ypz-zpz,
					-xp, yp-ypy-zpy, zp-ypz-zpz,
					-xp, yp+ypy-zpy, zp+ypz-zpz,
					+xp, yp+ypy-zpy, zp+ypz-zpz,
					+xp, yp-ypy-zpy, zp-ypz-zpz );
		multiline(4,-xp, yp-ypy+zpy, zp-ypz+zpz,
					-xp, yp+ypy+zpy, zp+ypz+zpz,
					+xp, yp+ypy+zpy, zp+ypz+zpz,
					+xp, yp-ypy+zpy, zp-ypz+zpz );
		multiline(4,-xp, yp+ypy-zpy, zp+ypz-zpz,
					-xp, yp+ypy+zpy, zp+ypz+zpz,
					+xp, yp+ypy+zpy, zp+ypz+zpz,
					+xp, yp+ypy-zpy, zp+ypz-zpz );
		line(-wvb/2.,-hvb/2.,0,-wvb/2.,hvb/2.,0);

		/* reflectors */
		// different color (red?), only on bottom surface of blades
	}
%}

END
